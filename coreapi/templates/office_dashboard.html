{% extends "base.html" %}
{% load static %}
{% block title %}Office Dashboard ‚Äî Vadrida{% endblock %}

{% block extra_head %}
<link rel="stylesheet" href="{% static 'css/dashboard.css' %}">
{% endblock %}

{% block content %}
<div class="relative">
  <!-- Loading overlay for Analyse action -->
  <div id="analyseLoading" class="loading-overlay hidden">
    <div class="spinner"></div>
    <div class="text-lg font-semibold">Analyzing ‚Äî please wait...</div>
    <div class="text-sm">Processing your file...</div>
  </div>

  <div class="dashboard-grid">
    <aside class="bg-white rounded-lg p-4 shadow-sm">
      <div class="flex items-center justify-between mb-4 flex-shrink-0">
        <h3 class="font-montserrat font-semibold">Files</h3>
        <button id="refreshFolders" class="px-3 py-1 border rounded text-sm">üîÑ</button>
      </div>

      <div class="mb-3 flex-shrink-0">
        <input id="fileSearch" type="text" placeholder="Search file id or name..." class="w-full p-2 rounded border" />
      </div>

      <div class="file-list-scroll mb-4 flex-1 overflow-y-auto">
        <div class="flex items-center gap-2 mb-2 text-sm">
          <button id="goBackBtn" class="px-2 py-1 border rounded">‚¨Ö</button>
          <span id="currentPath">/</span>
        </div>

        <ul id="fileList" class="space-y-2 text-sm"></ul>
      </div>

      <!-- File info moved into left panel -->
      <div class="file-info bg-white border rounded p-3 mt-auto flex-shrink-0">
        <h4 class="font-semibold mb-2">File Info</h4>
        <div id="fileInfoBox" class="text-sm text-gray-600">
          Select a file to see details.
        </div>
      </div>
    </aside>

    <!-- CENTER: Big preview + controls -->
    <section class="bg-white rounded-lg shadow-sm">
      <div class="flex items-center justify-between mb-3 flex-shrink-0 p-3">
        <h3 class="font-montserrat font-semibold">Preview</h3>
        <div class="flex gap-2 flex-wrap">
          <button id="analyseBtn" class="analyse-btn px-4 py-2 rounded">Analyse</button>
          <a id="siteFeedbackBtn" href="{% url 'coreapi:feedback' %}" class="px-4 py-2 border rounded bg-gray-100 hover:bg-gray-200">
            Site Feedback
          </a>
          <button id="openFullBtn" class="px-3 py-2 border rounded">Open Full</button>
        </div>
      </div>

      <!-- Thumbnails row (populated dynamically) -->
      <div id="thumbs" class="thumbs-strip mb-3 px-3"></div>

      <!-- Large viewer -->
      <div class="preview-shell rounded border mx-3 mb-3">
        <div id="bigPreviewHeader" class="flex items-center justify-between px-4 py-2 bg-white border-b flex-shrink-0">
          <div class="font-medium text-sm truncate" id="bigPreviewTitle">No file selected</div>
          <div class="flex items-center gap-2">
            <button id="downloadPdfBtn" class="px-2 py-1 border rounded text-xs hidden download-btn">
              <i class="fas fa-file-download"></i>
            </button>
          </div>
        </div>

        <div id="bigViewer" class="relative h-full flex flex-col bg-gray-100">
  
  <div id="noSelection" class="flex items-center justify-center h-full text-gray-400">
    Select a file to preview
  </div>

  <div id="pdfToolbar" class="hidden flex items-center justify-between px-4 py-2 bg-white border-b shadow-sm z-10">
    <div class="text-sm font-semibold text-gray-600" id="pageCountDisplay">Page 1</div>
    <div class="flex items-center gap-2">
      <button id="pdfZoomOut" class="px-2 py-1 bg-gray-100 border rounded hover:bg-gray-200"><i class="fas fa-minus"></i></button>
      <span id="zoomLevelDisplay" class="text-xs w-12 text-center">100%</span>
      <button id="pdfZoomIn" class="px-2 py-1 bg-gray-100 border rounded hover:bg-gray-200"><i class="fas fa-plus"></i></button>
    </div>
  </div>

  <div id="scrollContainer" class="hidden flex-1 overflow-y-auto p-4 flex flex-col items-center gap-4">
     <div id="scrollSentinel" class="w-full h-20 flex items-center justify-center text-gray-400">
        <div class="spinner border-4 border-gray-300 border-t-blue-500 rounded-full w-6 h-6 animate-spin"></div>
     </div>
  </div>


</div>
      </div>
    </section>

    <!-- RIGHT: WhatsApp-Style Chat -->
    <aside class="bg-white rounded-lg p-4 shadow-sm">
  
  <div class="flex items-center justify-between p-3 border-b bg-white" style="flex-shrink: 0;">
    <h3 class="font-montserrat font-semibold text-lg">Team Chat</h3>
    
  </div>

  <div id="pinnedMessages" class="px-3 pt-2 space-y-2" style="flex-shrink: 0;"></div>

  <div 
    id="chatBox" 
    class="bg-gray-50"
    style="flex: 1; overflow-y: auto; min-height: 0; padding: 10px; display: flex; flex-direction: column;"
  >
      </div>

  <form 
    id="chatForm" 
    style="flex-shrink: 0; padding: 10px; border-top: 1px solid #eee; display: flex; align-items: center; gap: 8px; background: white;"
  >
    
    <label class="cursor-pointer p-2 hover:bg-gray-100 rounded-full text-gray-500 hover:text-blue-600 transition" style="flex-shrink: 0;">
      <input type="file" id="fileInput" class="hidden" accept="image/*,.pdf,.doc,.docx" />
      <i class="fas fa-paperclip text-lg"></i>
    </label>

    <input
      id="chatInput"
      type="text"
      placeholder="Type a message..."
      class="border border-gray-300 rounded-full px-4 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500"
      style="flex: 1; min-width: 0;"
      autocomplete="off"
    />

    <button 
      type="submit" 
      class="bg-blue-600 hover:bg-blue-700 text-white rounded-full flex items-center justify-center shadow-sm transition"
      style="flex-shrink: 0; width: 40px; height: 40px; border: none; cursor: pointer;"
    >
      <i class="fas fa-paper-plane text-sm ml-[-2px]"></i>
    </button>
  </form>
</aside>
  </div>
</div>

<!-- Fullscreen modal for preview -->
<div id="fullscreenModal" aria-hidden="true">
  <div class="modal-box">
    
    <div class="flex items-center justify-between p-3 border-b bg-white z-50 relative">
      <div class="font-semibold truncate max-w-[200px]" id="modalTitle">Preview</div>

      <div>
        <button id="modalZoomOut">
         
        </button>
        
        <button id="modalZoomIn">
         
        </button>
        <button id="modalZoomReset">
          
        </button>
      </div>

      <div class="flex items-center gap-2 flex-wrap">
        
        <div id="shareButtonsContainer" class="flex space-x-2 hidden absolute top-14 right-4 bg-white shadow-xl p-2 rounded-lg border z-50">
          <a href="#" id="shareWhatsapp" class="p-2 hover:bg-green-50 rounded text-green-600"><i class="fab fa-whatsapp text-xl"></i></a>
          <a href="#" id="shareTelegram" class="p-2 hover:bg-blue-50 rounded text-blue-500"><i class="fab fa-telegram text-xl"></i></a>
          <a href="#" id="shareEmail" class="p-2 hover:bg-gray-50 rounded text-gray-600"><i class="fas fa-envelope text-xl"></i></a>
          <a href="#" id="shareCopy" class="p-2 hover:bg-gray-50 rounded text-gray-600"><i class="fas fa-link text-xl"></i></a>
        </div>

        <button id="modalShare" class="px-3 py-2 rounded border text-sm hover:bg-gray-50 transition">
          <i class="fas fa-share-alt"></i> <span class="hidden sm:inline">Share</span>
        </button>

        <button id="modalDownloadBtn" class="px-3 py-2 rounded border text-sm hover:bg-gray-50 transition">
          <i class="fas fa-file-download"></i> <span class="hidden sm:inline">Download</span>
        </button>

        <button id="modalClose" class="px-3 py-2 bg-red-50 text-red-600 border border-red-100 rounded text-sm hover:bg-red-100 transition">Close</button>
      </div>
    </div>

    <div id="modalBody" class="modal-inner relative bg-gray-100 flex items-center justify-center overflow-hidden" style="height: calc(100% - 60px);">
      
      <iframe id="modalFrame" class="hidden w-full h-full border-none"></iframe>
      
      <div id="imageZoomWrapper" class="hidden w-full h-full overflow-auto flex items-center justify-center">
         <img id="modalImage" class="transition-transform duration-200 origin-center" src="" alt="preview" style="max-width: 100%; max-height: 100%; object-fit: contain;" />
      </div>
      
      <div id="modalPdfContainer" class="hidden w-full h-full overflow-y-auto flex flex-col items-center bg-gray-200 pt-4 pb-10"></div>
    
    </div>
  </div>
</div>

<!-- Analyse Modal -->
<div id="analyseModal" class="fixed inset-0 bg-black bg-opacity-50 hidden flex items-center justify-center z-50">
  <div class="bg-white rounded-xl p-6 w-96 max-w-[90vw] shadow-xl">
    <h2 class="text-lg font-semibold mb-4">Analyse Files</h2>
    <p class="text-sm text-gray-600 mb-4">Choose files for analysis</p>

    <button id="analyseSelectFiles" class="w-full mb-3 px-4 py-2 bg-blue-600 text-white rounded">
      Select Files
    </button>

    <button id="analyseSelectAll" class="w-full px-4 py-2 bg-green-600 text-white rounded">
      Select All Files
    </button>

    <button id="analyseClose" class="w-full mt-4 px-4 py-2 border rounded">
      Cancel
    </button>
  </div>
</div>

<!-- File Selection List Modal -->
<div id="fileSelectModal" class="fixed inset-0 bg-black bg-opacity-50 hidden flex items-center justify-center z-50">
  <div class="bg-white rounded-xl p-6 w-[420px] max-w-[90vw] shadow-xl">
    <h2 class="text-lg font-semibold mb-4">Select Files</h2>

    <div id="fileSelectList" class="max-h-64 overflow-y-auto border rounded p-3 mb-4"></div>

    <button id="confirmFileSelection" class="w-full px-4 py-2 bg-blue-600 text-white rounded">
      Confirm Selection
    </button>

    <button id="fileSelectClose" class="w-full mt-3 px-4 py-2 border rounded">
      Cancel
    </button>
  </div>
</div>

<script>
/* =========================
   CSRF
========================= */
function getCookie(name) {
  let v = null;
  document.cookie?.split(";").forEach(c => {
    c = c.trim();
    if (c.startsWith(name + "=")) v = decodeURIComponent(c.slice(name.length + 1));
  });
  return v;
}
const csrftoken = getCookie("csrftoken");

/* =========================
   ELEMENTS
========================= */
const fileList = document.getElementById("fileList");
const thumbsContainer = document.getElementById("thumbs");
const bigImageFrame = document.getElementById("bigImageFrame");
const noSelection = document.getElementById("noSelection");
const bigPreviewTitle = document.getElementById("bigPreviewTitle");
const openModalBtn = document.getElementById("openFullBtn");
const fileInfoBox = document.getElementById("fileInfoBox");
const pdfWrapper = document.getElementById("pdfWrapper");
const pdfMain = document.getElementById("pdfMain");

/* =========================
   STATE
========================= */
let currentFolder = "";
let currentFile = null;
let analysisController = null;
let currentFolderFiles = [];
let selectedAnalysisFiles = [];
let rootFoldersCache = null;
let isSearching = false;
let currentPreviewUrl = null;

/* =========================
   FOLDER LOADER
========================= */
function loadFolder(path = "") {
  currentFolder = path;
  document.getElementById("currentPath").textContent = "/" + (path || "");

  fetch(`/coreapi/api/folder-contents/?path=${encodeURIComponent(path)}`)
    .then(r => r.json())
    .then(data => {
      currentFolderFiles = data.files || [];
      renderFileList(data.folders || [], data.files || []);
      renderThumbs(data.files || []);
    });
}

document.getElementById("goBackBtn").onclick = () => {
  if (!currentFolder) return;
  const parts = currentFolder.split("/");
  parts.pop();
  loadFolder(parts.join("/"));
};

/* =========================
   FILE LIST
========================= */
function renderFileList(folders, files) {
  fileList.innerHTML = "";

  folders.forEach(folder => {
    const li = document.createElement("li");
    li.className = "p-2 cursor-pointer hover:bg-blue-50 flex items-center gap-2";
    li.innerHTML = `üìÅ <strong>${folder.name}</strong>`;
    li.onclick = () => loadFolder(folder.path);
    fileList.appendChild(li);
  });

  files.forEach(file => {
    const li = document.createElement("li");
    li.className = "p-2 cursor-pointer hover:bg-gray-100";
    li.innerHTML = `
      <div class="flex justify-between items-center">
        <div>
          <div class="font-medium truncate">${file.name}</div>
          <div class="text-xs text-gray-500">${file.extension || ""}</div>
        </div>
        <button class="pin-btn">üìå</button>
      </div>
    `;

    li.querySelector(".pin-btn").onclick = (e) => {
      e.stopPropagation();
      pendingAttachment = {
        type: "file",
        path: file.path,
        label: file.name
      };
    };
    li.onclick = () => {
      document.querySelectorAll("#fileList li").forEach(el => el.classList.remove("bg-blue-100"));
      li.classList.add("bg-blue-100");
      loadBigPreview(file);
      setFileInfo(file);
    };

    fileList.appendChild(li);
  });

  if (!folders.length && !files.length) {
    fileList.innerHTML = `<li class="p-3 text-gray-400">No results</li>`;
  }
}

/* =========================
   THUMBNAILS
========================= */

// 1. Helper to load PDF.js library if not present
function loadPdfJsIfNeeded() {
  if (window.pdfjsLib) return Promise.resolve();
  
  return new Promise((resolve, reject) => {
    const script = document.createElement("script");
    // Using a reliable CDN version
    script.src = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js";
    
    script.onload = () => {
      // Set the worker source immediately after loading
      window.pdfjsLib.GlobalWorkerOptions.workerSrc = 
        "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";
      resolve();
    };
    
    script.onerror = () => reject(new Error("Could not load PDF.js"));
    document.head.appendChild(script);
  });
}

// 2. Render PDF Thumbnail (Now accepts a direct URL)
async function renderPdfThumbnail(pdfUrl, container) {
  try {
    await loadPdfJsIfNeeded();

    // Fetch the PDF using the calculated URL
    const loadingTask = pdfjsLib.getDocument(pdfUrl);
    const pdf = await loadingTask.promise;
    
    // Get the first page
    const page = await pdf.getPage(1);

    // Calculate scale to fit the thumbnail container (approx 100x100)
    // We render slightly larger (scale 0.5) for sharpness, then resize via CSS
    const viewport = page.getViewport({ scale: 0.5 });
    
    const canvas = document.createElement("canvas");
    const context = canvas.getContext("2d");
    
    canvas.width = viewport.width;
    canvas.height = viewport.height;
    
    // Force CSS styles to ensure it stays inside the thumbnail box
    canvas.style.width = "100%";
    canvas.style.height = "100%";
    canvas.style.objectFit = "contain";

    await page.render({
      canvasContext: context,
      viewport: viewport
    }).promise;

    container.appendChild(canvas);
    
  } catch (error) {
    console.error("PDF Thumb Error:", error);
    // Fallback Icon
    container.innerHTML = `
      <div class="file-icon" style="color: #dc2626; text-align: center;">
        <i class="fas fa-file-pdf" style="font-size: 24px;"></i><br>
        <span style="font-size: 10px;">PDF</span>
      </div>`;
  }
}

// 3. Main Thumbnail Function
/* =========================
   FAST SERVER-SIDE THUMBNAILS
   (No PDF.js needed for list view!)
========================= */
function renderThumbs(files) {
  thumbsContainer.innerHTML = "";

  if (!files.length) {
    thumbsContainer.innerHTML = `<div class="no-thumbs">No files to preview</div>`;
    return;
  }

  // Clear any previous processing queue
  // (This fixes the "Files appearing in wrong folder" issue)
  // Since we use standard <img> tags now, the browser handles cancellation automatically.

  files.forEach(file => {
    const card = document.createElement("div");
    card.className = "thumb-item";
    
    const ext = file.name.split(".").pop().toLowerCase();
    
    // Logic: If it's an Image OR a PDF, ask server for a thumbnail
    if (['jpg', 'jpeg', 'png', 'gif', 'pdf'].includes(ext)) {
        const img = document.createElement("img");
        
        // --- THE MAGIC LINE ---
        // We point the image source to our new Python view
        // We add a timestamp to prevent the browser from caching the WRONG image
        img.src = `/coreapi/api/thumbnail/?path=${encodeURIComponent(file.path)}&t=${new Date().getTime()}`;
        
        img.loading = "lazy"; // Only load when scrolled into view
        
        // Setup visuals
        img.style.objectFit = "contain";
        img.style.width = "100%";
        img.style.height = "100%";

        // Error handling (If server fails, show icon)
        img.onerror = () => {
            card.innerHTML = `<div class="file-icon"><i class="fas fa-file-pdf"></i><br>${ext.toUpperCase()}</div>`;
        };

        card.appendChild(img);
    } else {
        // Generic Icon for Word/Excel/etc
        card.innerHTML = `<div class="file-icon"><i class="fas fa-file-alt"></i><br>${ext.toUpperCase()}</div>`;
    }

    // Click Event (Keep this same as before)
    card.onclick = () => {
      document.querySelectorAll(".file-item").forEach(el => el.classList.remove("selected"));
      loadBigPreview(file);
      setFileInfo(file);
    };

    thumbsContainer.appendChild(card);
  });
}
/* =========================
   PREVIEW
========================= */
function loadBigPreview(file) {
  currentFile = file;

  // Hard reset
  pdfMain.innerHTML = "";
  pdfWrapper.classList.add("hidden");
  bigImageFrame.classList.add("hidden");
  noSelection.classList.add("hidden");
  bigImageFrame.src = "";

  const url = `/coreapi/serve-file/?path=${encodeURIComponent(file.path)}`;
  currentPreviewUrl = url;
  bigPreviewTitle.textContent = file.name;

  const ext = file.name.split(".").pop().toLowerCase();

  // IMAGE
  if (["jpg","jpeg","png","gif","bmp"].includes(ext)) {
    bigImageFrame.src = url;
    bigImageFrame.classList.remove("hidden");
    return;
  }

  // PDF
  if (ext === "pdf") {
    pdfWrapper.classList.remove("hidden");
    renderFullPdf(url);
    return;
  }

  // OTHER
  noSelection.textContent = "Preview not available for this file type";
  noSelection.classList.remove("hidden");
}

/* =========================
   FILE INFO
========================= */
function setFileInfo(file) {
  fileInfoBox.innerHTML = `
    <div class="mb-1"><strong>Name:</strong> <span class="text-xs break-all">${file.name}</span></div>
    <div class="mb-1"><strong>Type:</strong> ${file.extension || "Unknown"}</div>
    <div><strong>Size:</strong> ${file.size || "N/A"}</div>
  `;
}

/* =========================
   ANALYSE
========================= */
function startAnalysis(files) {
  if (analysisController) {
    analysisController.abort();
  }

  analysisController = new AbortController();
  document.getElementById("analyseLoading").classList.remove("hidden");

  fetch("/coreapi/api/analyze/", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "X-CSRFToken": csrftoken
    },
    body: JSON.stringify({ files, folder: currentFolder }),
    signal: analysisController.signal
  })
  .then(r => r.json())
  .then(() => loadFolder(currentFolder))
  .finally(() => {
    document.getElementById("analyseLoading").classList.add("hidden");
    analysisController = null;
  });
}

const analyseBtn = document.getElementById("analyseBtn");
const analyseModal = document.getElementById("analyseModal");

analyseBtn.onclick = () => {
  if (!currentFolder) {
    alert("Select a folder first");
    return;
  }
  analyseModal.classList.remove("hidden");
};

document.getElementById("analyseSelectAll").onclick = () => {
  if (!currentFolderFiles.length) {
    alert("No files in this folder");
    return;
  }

  const files = currentFolderFiles.map(f => ({ file_path: f.path }));
  analyseModal.classList.add("hidden");
  startAnalysis(files);
};

const fileSelectModal = document.getElementById("fileSelectModal");
const fileSelectList = document.getElementById("fileSelectList");

document.getElementById("analyseSelectFiles").onclick = () => {
  if (!currentFolderFiles.length) {
    alert("No files in this folder");
    return;
  }

  fileSelectList.innerHTML = "";
  selectedAnalysisFiles = [];

  currentFolderFiles.forEach(file => {
    const row = document.createElement("label");
    row.className = "flex items-center gap-2 mb-2 cursor-pointer";
    row.innerHTML = `
      <input type="checkbox" value="${file.path}" />
      <span class="truncate">${file.name}</span>
    `;

    const checkbox = row.querySelector("input");
    checkbox.onchange = () => {
      if (checkbox.checked) {
        selectedAnalysisFiles.push({ file_path: checkbox.value });
      } else {
        selectedAnalysisFiles = selectedAnalysisFiles.filter(f => f.file_path !== checkbox.value);
      }
    };

    fileSelectList.appendChild(row);
  });

  analyseModal.classList.add("hidden");
  fileSelectModal.classList.remove("hidden");
};

document.getElementById("confirmFileSelection").onclick = () => {
  if (!selectedAnalysisFiles.length) {
    alert("Select at least one file");
    return;
  }

  fileSelectModal.classList.add("hidden");
  startAnalysis(selectedAnalysisFiles);
};

document.getElementById("analyseClose").onclick = () => {
  analyseModal.classList.add("hidden");
};

document.getElementById("fileSelectClose").onclick = () => {
  fileSelectModal.classList.add("hidden");
};

/* =========================
   SEARCH DEBOUNCE (Prevents Spamming Server)
========================= */
const searchInput = document.getElementById("fileSearch");
let searchTimer = null;

searchInput.addEventListener("input", e => {
  const q = e.target.value.trim();
  
  // Clear any existing timer
  clearTimeout(searchTimer);

  // Wait 500ms before sending the request
  searchTimer = setTimeout(() => {
    if (!q) { 
        loadFolder(currentFolder); 
        return; 
    }
    
    // Only search if the user stopped typing for 500ms
    globalSearch(q);
  }, 500); // Increased from 300ms to 500ms
});

/* =========================
   PDF.JS LOADER
========================= */
function loadPdfJsIfNeeded() {
  if (window.pdfjsLib) return Promise.resolve();

  return new Promise((resolve, reject) => {
    const script = document.createElement("script");
    script.src = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js";

    script.onload = () => {
      pdfjsLib.GlobalWorkerOptions.workerSrc =
        "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";
      resolve();
    };

    script.onerror = reject;
    document.head.appendChild(script);
  });
}

/* =========================
   GLOBAL SEARCH
========================= */
function globalSearch(query) {
  isSearching = true;
  fileList.innerHTML = `<li class="p-2 text-gray-400">Searching...</li>`;
  thumbsContainer.innerHTML = "";

  fetch(`/coreapi/api/search/?q=${encodeURIComponent(query)}`)
    .then(r => r.json())
    .then(data => {
      renderFileList(data.folders || [], data.files || []);
      renderThumbs(data.files || []);
    })
    .catch(() => {
      fileList.innerHTML = `<li class="p-2 text-red-500">Search failed</li>`;
    });
}

/* =========================
   REFRESH
========================= */
document.getElementById("refreshFolders").onclick = () => {
  fetch("/coreapi/api/refresh/")
    .then(() => {
      rootFoldersCache = null;
      searchInput.value = "";
      loadFolder("");
    });
};


document.getElementById("modalClose").onclick = () => {
  // Close logic supporting both class and aria attribute
  fullscreenModal.classList.remove("active");
  fullscreenModal.setAttribute("aria-hidden", "true");
  
  modalFrame.src = "";
  modalImage.src = "";
  document.getElementById("modalPdfContainer").innerHTML = "";
};



function updateShareLinks(url) {
  const encoded = encodeURIComponent(window.location.origin + url);

  document.getElementById("shareWhatsapp").href = `https://wa.me/?text=${encoded}`;
  document.getElementById("shareTelegram").href = `https://t.me/share/url?url=${encoded}`;
  document.getElementById("shareEmail").href = `mailto:?subject=Document&body=${encoded}`;

  document.getElementById("shareCopy").onclick = (e) => {
    e.preventDefault();
    navigator.clipboard.writeText(window.location.origin + url);
    alert("Link copied to clipboard");
  };
}


/* =========================
   INIT
========================= */
document.addEventListener("DOMContentLoaded", () => {
  console.log("Dashboard JS loaded");
  loadFolder("");
});

</script>

<script>
/* =========================
   CHAT STATE
========================= */
const CURRENT_USERNAME = "{{ request.user_profile.user_name|default:request.session.user_name }}";
const chatBox = document.getElementById("chatBox");
const chatForm = document.getElementById("chatForm");
const chatInput = document.getElementById("chatInput");
const pinnedBox = document.getElementById("pinnedMessages");
const fileInput = document.getElementById("fileInput");

let pendingAttachment = null;

/* =========================
   WEBSOCKET
========================= */

const protocol = location.protocol === "https:" ? "wss" : "ws";
const ws = new WebSocket(`${protocol}://${location.host}/ws/chat/global/`);

ws.onopen = () => console.log("‚úÖ WS connected");
ws.onerror = e => console.error("‚ùå WS error", e);

ws.onmessage = e => {
  const msg = JSON.parse(e.data);
  renderMessage(msg);
};

/* =========================
   LOAD HISTORY
========================= */

fetch("/chat/history/")
  .then(r => r.json())
  .then(data => {
    if (Array.isArray(data.pins)) {
      data.pins.forEach(renderPinned);
    }
    if (Array.isArray(data.messages)) {
      data.messages.forEach(renderMessage);
    }
  });

/* =========================
   SEND MESSAGE
========================= */

chatForm.onsubmit = e => {
  e.preventDefault();

  if (!chatInput.value.trim() && !pendingAttachment) return;

  ws.send(JSON.stringify({
    user: CURRENT_USERNAME,
    content: chatInput.value,
    attached_type: pendingAttachment ? pendingAttachment.type : "text",
    attached_path: pendingAttachment ? pendingAttachment.path : null,
    attached_label: pendingAttachment ? pendingAttachment.label : null,
  }));

  chatInput.value = "";
  pendingAttachment = null;
};

/* =========================
   RENDER MESSAGE
========================= */

function renderMessage(msg) {
    // DEBUG: Check why names aren't matching
    // Remove this console.log after it works
    console.log(`Checking: '${msg.user}' vs '${CURRENT_USERNAME}'`);

    // 1. ROBUST COMPARISON (Ignore Case & Spaces)
    const sender = String(msg.user).trim().toLowerCase();
    const me = String(CURRENT_USERNAME).trim().toLowerCase();
    const isMe = (sender === me);
    
    // 2. CONTAINER DIV (Flex Alignment)
    const div = document.createElement("div");
    // 'w-full' ensures it spans across. 'flex' allows alignment.
    div.className = "w-full mb-2 flex"; 
    div.style.justifyContent = isMe ? "flex-end" : "flex-start";

    // 3. COLORS & STYLING
    // Green (#dcf8c6) for Me, White (#fff) for Others
    const bgStyle = isMe 
        ? "background-color: #dcf8c6; border-top-right-radius: 0;" 
        : "background-color: #ffffff; border-top-left-radius: 0;";

    // 4. ATTACHMENT
    let attachHtml = "";
    if (msg.attached_type !== "none" && msg.attached_path) {
        let icon = "fa-file-alt";
        if (msg.attached_path.endsWith(".pdf")) icon = "fa-file-pdf text-red-500";
        else if (msg.attached_path.match(/\.(jpg|jpeg|png|gif)$/i)) icon = "fa-file-image text-blue-500";

        attachHtml = `
            <div class="mt-1 mb-1 p-2 bg-black/5 rounded border border-black/10 cursor-pointer flex items-center gap-2 hover:bg-black/10 transition"
                 onclick="handleChatAttachmentClick('${msg.attached_path}', '${msg.attached_label}')">
                <i class="fas ${icon}"></i>
                <span class="text-xs font-medium truncate max-w-[150px] underline">${msg.attached_label}</span>
            </div>
        `;
    }

    // 5. NAME LABEL (Only show for others)
    const userLabel = !isMe 
        ? `<div class="text-[10px] font-bold text-orange-600 mb-1 uppercase tracking-wide">${msg.user}</div>` 
        : "";
    
    const checkmark = isMe ? '<i class="fas fa-check-double text-blue-500 ml-1 text-[10px]"></i>' : '';

    // 6. INJECT HTML (Using Inline Styles to guarantee layout)
    div.innerHTML = `
        <div style="${bgStyle} max-width: 85%; padding: 8px 12px; border-radius: 12px; box-shadow: 0 1px 2px rgba(0,0,0,0.15); position: relative; min-width: 100px;">
            ${userLabel}
            ${attachHtml}
            <div class="text-sm text-gray-800 leading-relaxed whitespace-pre-wrap break-words">${msg.content}</div>
            <div class="text-[9px] text-gray-500 text-right mt-1 flex justify-end items-center gap-1">
                ${msg.time} ${checkmark}
            </div>
        </div>
    `;

    chatBox.appendChild(div);
    chatBox.scrollTop = chatBox.scrollHeight;
}
/* =========================
   PIN RENDERING (HISTORY ONLY)
========================= */

function renderPinned(pin) {
  const div = document.createElement("div");
  div.className = "bg-yellow-100 p-2 rounded cursor-pointer";

  div.innerHTML = `
    <strong>üìå ${pin.value}</strong>
    <div class="text-xs text-gray-600">Pinned by ${pin.by}</div>
  `;

  pinnedBox.appendChild(div);
}

/* =========================
   FILE UPLOAD
========================= */

fileInput.onchange = () => {
  const file = fileInput.files[0];
  if (!file) return;

  const formData = new FormData();
  formData.append("file", file);

  fetch("/chat/upload/", {
    method: "POST",
    headers: { "X-CSRFToken": csrftoken },
    body: formData
  })
    .then(r => r.json())
    .then(data => {
      pendingAttachment = {
        type: "file",
        path: data.path,
        label: data.label
      };
    });
};

/* =========================
   OPEN PINNED FILE / FOLDER
========================= */

function openPinnedReference(msg) {
  if (!msg.attached_path) return;

  const parts = msg.attached_path.split("/");
  const folder = parts.slice(0, -1).join("/");

  loadFolder(folder);
  waitForFileAndPreview(msg.attached_path);
}

function waitForFileAndPreview(path, tries = 10) {
  const file = currentFolderFiles.find(f => f.path === path);
  if (file) {
    loadBigPreview(file);
    return;
  }
  if (tries > 0) {
    setTimeout(() => waitForFileAndPreview(path, tries - 1), 300);
  }
}
</script>
<script>
document.getElementById("siteFeedbackBtn").onclick = () => {
  window.location.href = "feedback/";
};

/* ==========================================
   SERVER-SIDE INFINITE SCROLL PDF VIEWER
   ========================================== */

// State
let viewerState = {
    path: null,
    nextPageToLoad: 0,
    zoom: 1.0,
    isLoading: false,
    isFinished: false // True when we hit the last page
};

// Elements
const scrollContainer = document.getElementById("scrollContainer");
const scrollSentinel = document.getElementById("scrollSentinel"); // The loading spinner at bottom
const pdfToolbar = document.getElementById("pdfToolbar");
const pageCountDisplay = document.getElementById("pageCountDisplay");
const zoomLevelDisplay = document.getElementById("zoomLevelDisplay");

// --- 1. INITIALIZE PREVIEW ---
function loadBigPreview(file) {
    currentFile = file;
    
    // Reset State
    viewerState.path = file.path;
    viewerState.nextPageToLoad = 0;
    viewerState.isLoading = false;
    viewerState.isFinished = false;

    // Reset UI
    document.getElementById("bigPreviewTitle").textContent = file.name;
    document.getElementById("noSelection").classList.add("hidden");
    document.getElementById("downloadPdfBtn").classList.remove("hidden");
    
    // Clear previous pages (Keep only the sentinel)
    // We remove all img elements before the sentinel
    const existingImages = scrollContainer.querySelectorAll('img.pdf-page-img');
    existingImages.forEach(img => img.remove());

    const ext = file.name.split(".").pop().toLowerCase();

    // CASE A: PDF (Vertical Scroll)
    if (ext === "pdf") {
        scrollContainer.classList.remove("hidden");
        pdfToolbar.classList.remove("hidden");
        scrollSentinel.classList.remove("hidden"); // Show spinner
        
        // Start observing for scroll
        observer.observe(scrollSentinel);
        
        // Load Page 0 immediately
        loadNextPage();
    } 
    // CASE B: Image
    else if (["jpg", "jpeg", "png", "gif"].includes(ext)) {
        scrollContainer.classList.remove("hidden");
        pdfToolbar.classList.add("hidden");
        scrollSentinel.classList.add("hidden"); // No infinite scroll for single images
        
        const img = createPageImage(0, true); // True = is single image
        img.src = `/coreapi/serve-file/?path=${encodeURIComponent(file.path)}`;
        scrollContainer.insertBefore(img, scrollSentinel);
    }
    else {
        scrollContainer.classList.add("hidden");
        document.getElementById("noSelection").classList.remove("hidden");
        document.getElementById("noSelection").textContent = "Preview not available.";
    }
}

// --- 2. LOAD NEXT PAGE LOGIC ---
function loadNextPage() {
    if (viewerState.isLoading || viewerState.isFinished) return;
    
    viewerState.isLoading = true;

    // specific page index to load
    const pageIndex = viewerState.nextPageToLoad;
    
    // Create the image element placeholder
    const img = createPageImage(pageIndex);
    
    // Construct Backend URL
    // Note: We use the 'render-page' view we created earlier
    const url = `/coreapi/render-page/?path=${encodeURIComponent(viewerState.path)}&page=${pageIndex}&zoom=${viewerState.zoom}`;

    img.onload = () => {
        viewerState.isLoading = false;
        viewerState.nextPageToLoad++; // Prepare for next page
        
        // Update "Page X" display based on what is currently loaded
        pageCountDisplay.textContent = `Pages loaded: ${viewerState.nextPageToLoad}`;
        
        // If the Sentinel is still visible (big screen, small PDF), load another one immediately
        // This prevents getting stuck with only 1 page on a large monitor
        if (isSentinelVisible()) {
            loadNextPage();
        }
    };

    img.onerror = () => {
        // ERROR usually means 404 Not Found -> End of Document
        console.log("End of document reached or error.");
        viewerState.isFinished = true;
        viewerState.isLoading = false;
        img.remove(); // Remove the broken image
        scrollSentinel.classList.add("hidden"); // Hide the spinner
        observer.unobserve(scrollSentinel); // Stop watching
    };

    img.src = url;
    
    // Insert before the spinner
    scrollContainer.insertBefore(img, scrollSentinel);
}

// --- 3. HELPER: CREATE IMAGE ELEMENT ---
function createPageImage(index, isSingle = false) {
    const img = document.createElement("img");
    img.className = "pdf-page-img shadow-lg bg-white mb-4 transition-transform duration-200";
    img.alt = `Page ${index + 1}`;
    img.dataset.page = index;
    
    // Styles for nice paper look
    img.style.minHeight = isSingle ? "auto" : "800px"; // Placeholder height prevents jumpiness
    img.style.minWidth = "600px";
    img.style.maxWidth = "100%";
    
    if (isSingle) img.style.minHeight = "auto";

    return img;
}

// --- 4. INTERSECTION OBSERVER (Auto-Scroll) ---
// This watches the "spinner" at the bottom. When it appears on screen, it triggers loadNextPage()
const observer = new IntersectionObserver((entries) => {
    if (entries[0].isIntersecting) {
        loadNextPage();
    }
}, { root: scrollContainer, threshold: 0.1 });

function isSentinelVisible() {
    const rect = scrollSentinel.getBoundingClientRect();
    const containerRect = scrollContainer.getBoundingClientRect();
    return (rect.top <= containerRect.bottom);
}

// --- 5. ZOOM CONTROLS ---
// Since we have many images, we update CSS transform for all of them
function updateZoom() {
    const images = document.querySelectorAll('.pdf-page-img');
    images.forEach(img => {
        // We use CSS width % to handle zoom cleanly in a flex column
        // Base is 100% (fit width). 
        // Note: Real PDF viewers re-render at higher resolution on zoom. 
        // For simple CSS zoom:
        img.style.width = `${100 * viewerState.zoom}%`;
        img.style.maxWidth = "none"; // Allow it to overflow container if zoomed in
    });
    
    // Also re-render future pages at higher quality? 
    // For now, let's stick to CSS scaling for instant feedback.
    // If you want higher quality, we'd need to clear list and re-fetch with &zoom=X parameter.
    
    zoomLevelDisplay.textContent = `${Math.round(viewerState.zoom * 100)}%`;
}

document.getElementById("pdfZoomIn").onclick = () => {
    if (viewerState.zoom < 2.0) {
        viewerState.zoom += 0.25;
        updateZoom();
    }
};

document.getElementById("pdfZoomOut").onclick = () => {
    if (viewerState.zoom > 0.5) {
        viewerState.zoom -= 0.25;
        updateZoom();
    }
};


/* ==========================================
   UPDATED: FULLSCREEN MODAL WITH ZOOM
   ========================================== */

// 1. Get Modal Elements (Using UNIQUE IDs)
const fullscreenModal = document.getElementById("fullscreenModal");
const modalFrame = document.getElementById("modalFrame");
const modalImage = document.getElementById("modalImage");
const imageZoomWrapper = document.getElementById("imageZoomWrapper"); 
const modalPdfContainer = document.getElementById("modalPdfContainer");
const modalTitle = document.getElementById("modalTitle");

// 2. ZOOM CONTROLS (Renamed to avoid conflict with Dashboard)
const modalZoomDisplay = document.getElementById("modalZoomLevel"); // New ID
let currentModalZoom = 1.0; // Separate state for Modal

// 3. State
let modalState = {
    path: null,
    nextPage: 0,
    isLoading: false,
    isFinished: false,
    observer: null,
    mode: 'none'
};

/* --- OPEN MODAL BUTTON --- */
/* --- OPEN MODAL BUTTON --- */
document.getElementById("openFullBtn").onclick = () => {
    if (!currentFile) return alert("Select a file first");

    // 1. Show Modal
    const fullscreenModal = document.getElementById("fullscreenModal");
    const modalTitle = document.getElementById("modalTitle");
    
    fullscreenModal.classList.add("active");
    fullscreenModal.setAttribute("aria-hidden", "false");
    modalTitle.textContent = currentFile.name;

    // 2. GET ELEMENTS
    const modalFrame = document.getElementById("modalFrame");
    const imageZoomWrapper = document.getElementById("imageZoomWrapper");
    const modalPdfContainer = document.getElementById("modalPdfContainer");
    const modalImage = document.getElementById("modalImage");

    // 3. RESET ALL (Hide & Remove Flex)
    // We explicitly remove 'flex' and set display 'none' to prevent overlapping
    [modalFrame, imageZoomWrapper, modalPdfContainer].forEach(el => {
        el.classList.add("hidden");
        el.classList.remove("flex"); // Critical Fix
        el.style.display = "none";   // Double safety
    });
    
    modalPdfContainer.innerHTML = ""; // Clear old PDF pages
    
    // Reset Zoom State
    currentModalZoom = 1.0;
    if(typeof updateModalZoomUI === "function") updateModalZoomUI();

    modalState.path = currentFile.path;
    const ext = currentFile.name.split(".").pop().toLowerCase();

    // 4. CASE A: PDF
    if (ext === 'pdf') {
        modalState.mode = 'pdf';
        
        // Show PDF Container
        modalPdfContainer.classList.remove("hidden");
        modalPdfContainer.classList.add("flex"); // Restore Flex layout
        modalPdfContainer.style.display = "flex";
        
        initPdfModal();
    } 
    // 5. CASE B: IMAGE
    else if (["jpg","jpeg","png","gif","bmp","webp"].includes(ext)) {
        modalState.mode = 'image';
        
        // Show Image Wrapper
        imageZoomWrapper.classList.remove("hidden");
        imageZoomWrapper.classList.add("flex"); // Restore Flex layout
        imageZoomWrapper.style.display = "flex";
        
        modalImage.classList.remove("hidden");
        
        // Load High-Res
        modalImage.src = `/coreapi/serve-file/?path=${encodeURIComponent(currentFile.path)}`;
        
        // Reset Style
        modalImage.style.transform = "scale(1)";
        modalImage.style.maxWidth = "100%";
        modalImage.style.maxHeight = "100%";
        modalImage.style.margin = "0";
    }
    // 6. CASE C: OTHER
    else {
        // Fallback for non-previewable files
        modalPdfContainer.classList.remove("hidden");
        modalPdfContainer.classList.add("flex");
        modalPdfContainer.style.display = "flex";
        
        modalPdfContainer.innerHTML = `
            <div class="flex flex-col items-center justify-center h-full text-gray-500 gap-2">
                <i class="fas fa-file-alt text-4xl"></i>
                <span>Preview not available for this file type</span>
            </div>`;
    }
};
/* --- ZOOM LOGIC --- */
function applyModalZoom() {
    updateModalZoomUI();

    if (modalState.mode === 'image') {
        // IMAGE ZOOM
        if (currentModalZoom > 1.0) {
            modalImage.style.maxWidth = "none";
            modalImage.style.maxHeight = "none";
            modalImage.style.transform = `scale(${currentModalZoom})`;
            modalImage.style.margin = "50px"; 
        } else {
            modalImage.style.maxWidth = "100%";
            modalImage.style.maxHeight = "100%";
            modalImage.style.transform = "scale(1)";
            modalImage.style.margin = "0";
        }
    } 
    else if (modalState.mode === 'pdf') {
        // PDF ZOOM (Resize widths)
        const widthPercent = Math.round(currentModalZoom * 80); 
        const pages = modalPdfContainer.querySelectorAll("img");
        pages.forEach(p => {
            p.style.width = `${widthPercent}%`;
            p.style.maxWidth = "none";
        });
    }
}

function updateModalZoomUI() {
    const percent = Math.round(currentModalZoom * 100);
    // Use the NEW variable
    if(modalZoomDisplay) {
        modalZoomDisplay.textContent = percent === 100 ? "Fit" : `${percent}%`;
    }
}

// Button Listeners (Make sure IDs match your HTML)
document.getElementById("modalZoomIn").onclick = () => {
    if (currentModalZoom < 3.0) {
        currentModalZoom += 0.25;
        applyModalZoom();
    }
};

document.getElementById("modalZoomOut").onclick = () => {
    if (currentModalZoom > 0.5) {
        currentModalZoom -= 0.25;
        applyModalZoom();
    }
};

document.getElementById("modalZoomReset").onclick = () => {
    currentModalZoom = 1.0;
    applyModalZoom();
};

/* --- PDF INFINITE SCROLL --- */
/* --- PDF INFINITE SCROLL SETUP --- */
function initPdfModal() {
    modalState.nextPage = 0;
    modalState.isLoading = false;
    modalState.isFinished = false;

    // 1. Create Sentinel (The "Loading Spinner" at the bottom)
    const sentinel = document.createElement("div");
    sentinel.id = "modalSentinel";
    sentinel.className = "w-full flex items-center justify-center py-8";
    // Give it height so it can be "seen" by the observer
    sentinel.style.height = "100px"; 
    sentinel.style.flexShrink = "0"; // Prevent it from being squashed
    sentinel.innerHTML = '<div class="spinner border-4 border-gray-300 border-t-blue-500 rounded-full w-8 h-8 animate-spin"></div>';
    
    const container = document.getElementById("modalPdfContainer");
    container.appendChild(sentinel);

    // 2. Setup Observer
    if (modalState.observer) modalState.observer.disconnect();
    
    modalState.observer = new IntersectionObserver((entries) => {
        // Load next page if the spinner comes into view
        if (entries[0].isIntersecting) {
            loadNextModalPage(sentinel);
        }
    }, { 
        root: container, // Watch scrolling INSIDE the modal
        threshold: 0.1,  // Trigger when 10% of spinner is visible
        rootMargin: "200px" // Pre-load 200px before reaching bottom
    });
    
    modalState.observer.observe(sentinel);
    
    // 3. Trigger initial load immediately
    loadNextModalPage(sentinel);
}
function loadNextModalPage(sentinel) {
    if (modalState.isLoading || modalState.isFinished) return;
    modalState.isLoading = true;

    // 1. Create Image Page
    const img = document.createElement("img");
    const widthPercent = Math.round(currentModalZoom * 80); 
    
    // STYLE FIXES:
    img.style.width = `${widthPercent}%`;
    img.style.maxWidth = "none";
    img.style.marginBottom = "20px";
    img.style.boxShadow = "0 4px 10px rgba(0,0,0,0.2)";
    img.style.backgroundColor = "white";
    
    // CRITICAL: Prevent flexbox from shrinking the page height to 0
    img.style.flexShrink = "0"; 
    img.style.minHeight = "800px"; // Placeholder height while loading

    // 2. Set Source
    img.src = `/coreapi/render-page/?path=${encodeURIComponent(modalState.path)}&page=${modalState.nextPage}&zoom=1.5`;

    img.onload = () => {
        modalState.isLoading = false;
        modalState.nextPage++;
        
        // Remove placeholder height constraint once loaded
        img.style.minHeight = "auto"; 

        // CHECK: If content is still short (spinner visible), load next immediately
        const container = document.getElementById("modalPdfContainer");
        const sentinelRect = sentinel.getBoundingClientRect();
        const containerRect = container.getBoundingClientRect();

        if (sentinelRect.top < containerRect.bottom) {
             loadNextModalPage(sentinel);
        }
    };

    img.onerror = () => {
        // 404 means End of PDF
        console.log("End of PDF reached.");
        modalState.isFinished = true;
        sentinel.remove(); // Remove spinner
        if (modalState.observer) modalState.observer.disconnect();
    };

    // 3. Insert BEFORE the sentinel (Spinner stays at bottom)
    const container = document.getElementById("modalPdfContainer");
    container.insertBefore(img, sentinel);
}
/* --- CLOSE BUTTON --- */
document.getElementById("modalClose").onclick = () => {
    fullscreenModal.classList.remove("active");
    fullscreenModal.setAttribute("aria-hidden", "true");
    
    // Cleanup
    modalImage.src = "";
    modalPdfContainer.innerHTML = "";
    if (modalState.observer) modalState.observer.disconnect();
};
/* ==========================================
   UPDATED: DOWNLOAD BUTTONS
   ========================================== */

// 1. Dashboard Download Button (Small icon in header)
document.getElementById("downloadPdfBtn").onclick = (e) => {
    e.stopPropagation(); // Prevent glitches
    triggerDownload();
};

// 2. Modal Download Button (Big button in modal)
document.getElementById("modalDownloadBtn").onclick = () => {
    triggerDownload();
};

// Shared Download Function
function triggerDownload() {
    if (!currentFile) {
        alert("No file selected.");
        return;
    }
    // Points to the standard serve-file view with download=true
    const url = `/coreapi/serve-file/?path=${encodeURIComponent(currentFile.path)}&download=true`;
    window.location.href = url;
}


/* =========================
   ADVANCED FILE SHARING (Sends Actual File)
========================= */

// 1. Get Elements
const modalShareBtn = document.getElementById("modalShare");
const shareButtonsContainer = document.getElementById("shareButtonsContainer");
const modalDownloadBtn = document.getElementById("modalDownloadBtn");

// 2. Main Share Button Logic
modalShareBtn.onclick = async (e) => {
  e.preventDefault();
  
  if (!currentFile) return alert("No file selected");

  const originalText = modalShareBtn.innerHTML;
  
  // Visual Feedback: Show user we are preparing the file
  modalShareBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Preparing...';
  modalShareBtn.style.pointerEvents = "none"; // Prevent double click

  try {
      // A. Construct the Download URL
      const downloadUrl = `/coreapi/serve-file/?path=${encodeURIComponent(currentFile.path)}&download=true`;

      // B. Fetch the file data (Blob) from your server
      const response = await fetch(downloadUrl);
      const blob = await response.blob();

      // C. Create a Virtual File object
      // We use the correct MIME type (pdf, jpg, etc.)
      const fileObj = new File([blob], currentFile.name, { type: blob.type });

      // D. Check if the Device supports File Sharing
      if (navigator.canShare && navigator.canShare({ files: [fileObj] })) {
          
          // --- SUCCESS: Share the Actual File ---
          await navigator.share({
              files: [fileObj],
              title: currentFile.name,
              text: 'Here is the file.'
          });
          
      } else {
          // --- FALLBACK: Device doesn't support file sharing (e.g. Desktop) ---
          // We revert to the Link menu, but we tell the user why
          shareButtonsContainer.classList.toggle("hidden");
          
          // Still update links just in case they want to send the link instead
          const fileLink = window.location.origin + `/coreapi/serve-file/?path=${encodeURIComponent(currentFile.path)}`;
          updateShareLinks(fileLink);
      }

  } catch (err) {
      console.log('Share failed or canceled:', err);
      // If user canceled share, do nothing. If error, maybe show alert.
      if (err.name !== 'AbortError' && err.name !== 'NotAllowedError') {
          alert("Could not share file directly. Try downloading it first.");
      }
  } finally {
      // Reset Button
      modalShareBtn.innerHTML = originalText;
      modalShareBtn.style.pointerEvents = "auto";
  }
};

// 3. Fallback Links (Only used if File Sharing fails/Desktop)
function updateShareLinks(url) {
  const encodedUrl = encodeURIComponent(url);
  const encodedText = encodeURIComponent("Check this document: " + currentFile.name);

  // Note: These CANNOT attach files. This is a browser limitation.
  document.getElementById("shareWhatsapp").href = `https://wa.me/?text=${encodedText}%20${encodedUrl}`;
  document.getElementById("shareTelegram").href = `https://t.me/share/url?url=${encodedUrl}&text=${encodedText}`;
  document.getElementById("shareEmail").href = `mailto:?subject=${encodeURIComponent(currentFile.name)}&body=${encodedText}%20${encodedUrl}`;

  document.getElementById("shareCopy").onclick = (e) => {
    e.preventDefault();
    navigator.clipboard.writeText(url).then(() => {
        alert("Link copied to clipboard!");
        shareButtonsContainer.classList.add("hidden");
    });
  };
}

// 4. Download Button Logic
modalDownloadBtn.onclick = (e) => {
  e.preventDefault();
  if (!currentFile) return alert("No file selected");
  const downloadUrl = `/coreapi/serve-file/?path=${encodeURIComponent(currentFile.path)}&download=true`;
  window.location.href = downloadUrl;
};
</script>

{% endblock %}